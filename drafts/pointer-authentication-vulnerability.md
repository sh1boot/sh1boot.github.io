---
layout: post
title: Pointer authentication vulnerability and mitigations
tags: security computer-architecture needs-work needs-example
---
Pointer authentication involves taking things like the return address
and inserting an authentication tag into unused bits -- a cryptographic
signature -- before storing the pointer to memory, and then confirming
that the signature agrees with the pointer destination after loading it
back from memory and before using it again.

There's an issue here, in the case where the process of verifying the
signature does not lead to an immediate fault.  In that case if the
signature fails then it produces an invalid pointer and correspondingly,
to prevent misuse of this situation, trying to sign an invalid pointer
results in a pointer with a _deliberately incorrect_ signature.

### Tail call optimisation

You can see both of these cases working together in function tail call
optimisation.  When one function ends by calling another function, to
avoid extra steps it can jump directly to the beginning of the next
function and let that function perform the return to where the first
function was originally called.

When this optimisation is used the first function needs to ensure that
the link register points to the place it was called from.  Typically by
loading this value from the stack.  With pointer authentication this
value loaded from the stack would have its signature checked, and if the
signature fails then the pointer is set to an invalid value.

If the function returned here it would raise a fault trying to branch to
the invalid pointer.

But with tail call optimisation program flow instead jumps to the next
function.  That function adds a new authentication code to the pointer
in order to store it back on the stack.  But that operation also
recognises that the incoming pointer is invalid and so it corrupts the
signature to ensure that the next authentication check also fails and
eventually leads to a fault when it's used for a return branch.

### The bad signature

The problem is, the bad signature has to be a value which is definitely
not correct.  The way this was defined was to take the correct signature
and flip one of the bits, which is definitely not the same value.

But what if the attacker can exfiltrate that newly signed pointer,
and escape the function without actually using it?  Then they can flip
that bit back and now they know the correct signature for that pointer.

### A pointer-signing gadget

In all what they might do is make several passes through a tail-call
pair where they can read and write the return address from the first
function.  In the first pass read out the normal return address with its
proper signature.  In the second pass inject the pointer to be signed in
the return address of the first function but set things up so it won't
return via that pointer -- perhaps by forcing a `longjmp()` return, or
by injecting the normal return address back in there somewhere.  Then
read out the mis-signed return address, either later in the second
function, or in a third pass if it's been left lying around on the stack
from the previous return.

With the mis-signed attacker-controlled pointer obtained, without
crashing the program, that pointer can then be corrected to the proper
signature and re-injected.

### Leaking less

What perhaps could have happened was that the incorrect signature be
chosen from one of only two predefined patterns, choosing one or other
with a 50:50 chance but with a 100% chance of being wrong -- eg., choose
a repeating pattern except where one bit is definitely set to the
opposite value of the corresponding bit in the correct signature.  This
leaks one bit of the correct signature, which is at least better than
the previous solution.

Alternatively, leak nothing by returning a constant pattern but risk
producing the correct signature when that signature happens to collide
with the fixed fill pattern.  This sounds statistically reasonable but
may have unintended consequences.

### Leaking more

What the use of a static pattern doesn't help with is where the above
fails to be much use is where the attacker can just repeatedly inject
pointers without crashes, and get mis-signed pointers back, over and
over.  They can just keep doing this until they find the one that
doesn't change.  That one must be the right signature, and can be used
without causing a fault.

### Hiding bad signatures

Suppose the attacker doesn't get to see a copy of the un-signed pointers
because the code always signs pointers before writing them to memory.

What we need is for in-register pointers to be marked as bad but without
revealing that they were marked bad when they're converted back to
signed form.  That is, that the original bad signature matches the new
bad signature even after converting to and from an invalid pointer.
Then the attacker gets back unmodified pointers in all cases and they
don't learn which one was temporarily a valid pointer.

That would require a bijective transform where good signatures map to
good pointers and bad signatures map to bad pointers.  And back again.

That's unlikely to work out; but the coding space for signed pointers
and the coding space for invalid pointers should at least be comparable
in size, so an approximation where some bad signatures are corrupted but
many bad signatures are kept must at least be feasible.  Even if 3/4 of
bad signatures are eliminated from the search by being corrupted in the
transform that still hides the correct signature among many fakes.

### Minimising the changes

A naive approach would be for the signing and testing operations to
modify the pointer only if it has the correct input form, and otherwise
leave it at its original value.  This won't quite work because one can
inject a valid pointer where a signed pointer is expected and the result
of testing it will be its original value because the signature is wrong,
and you end up with a valid pointer and no fault.  So you need
additional rules that for both operations, when given a faulty input,
must alter their output iff the output would otherwise be valid,
otherwise leave it as its original value.  Given a valid input always
modify it to a valid output.

Sounds reasonable, but it needs further thought.  What happens when the
attacker's signed guess is also, coincidentally, a valid pointer, for
example?

### Thinking harder

To reason on this further I propose a 27-state system.  All combinations
of { signed (intentional), signed (coincidental), unsigned }, { valid
(intentional), valid (coincidental), invalid }, and { modified
(intentional), modified (evasive), unmodified } (maybe there are more
modified states, but the point is we want to maximise the case where
modifications cancel).  Formalising the transitions through each pointer
operation and walking them all through normal and subversive paths.

The original weakness is a thing I found years ago (and duly reported)
and has also been documented in a [Project Zero blog post][].  In that
write-up you'll find _real_ gadgets, whereas I just handwaved mine into
hypothetical existence.

If you read the pointer authentication spec there are other troublesome
cases described which might be used in combination to interesting
effect.  There's a mitigation I proposed involving tracking call paths
to make replay harder, but which wouldn't mitigate what I describe here.
Another approach might be to use a shadow stack (the same one as the CFI
return stack, I guess) of random values to be used as tweaks on the
signing function, which could be unique on every entry into a function
and saved for the duration of the function but not saved on the stack
which is vulnerable to exfiltration (this is important because the
random values might be predictable once you capture some).

[Project Zero blog post]: <https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html>
