---
layout: post
title: That time I found a weakness in Arm pointer authentication
categories: security, cpu, hardware
---
Pointer authentication involves taking things like the return address
and inserting an authentication tag into unused bits -- a cryptographic
signature -- before storing the pointer to memory, and then confirming
that the signature agrees with the pointer destination after loading it
back from memory and before using it again.

There's a weakness in the case where the process of verifying the
signature does not lead to an immediate fault.  In that case if the signature
fails then it produces an invalid pointer and, correspondingly, to prevent
misuse of this situation trying to sign an invalid pointer results in
a pointer with a _deliberately incorrect_ signature.

You see both of these cases working together with function tail call
optimisation.  Where one function ends by calling another function, it
can jump directly to the beginning of the next function instead of
calling the next function and then returning once that function returns
to it.  Instead, it just has to restore the return address to the link
register before the jump, so that the next function returns to where the
current function should return.  Before doing the jump, the calling
function will pop the return address and validate it, but if it's
corrupt then all it does is make the pointer invalid without raising a
fault.  The fault will instead happen when the called function tries to
use the corrupt return address.

The weakness was in the definition of that deliberate incorrectness when
signing an invalid pointer.  It turns out it was defined as a
predictable modification on a correct signature.  So if you can insert
your own return address without knowing the correct signature, but
then get it signed again and exfiltrate the result, you can deduce
a correct signature from that even though the value you capture is
notionally invalid.  Tail-call optimisation presents such an opportunity.

The next problem you have to address is avoiding the fault which
would normally come from the bad initial guess when the callee tries to return. 
One solution here might be to lead the code into a failure condition such that it calls
longjmp() or uses C++ exceptions to bypass the normal return stack
and then attempts to recover from the situation without tearing down
the program in a way that resets the pointer signing key.
Perhaps emulating a recoverable network fault, for example.
There are also potential weaknesses where the tear down procedure will not be able to reset the key.
In the retry you can do another injection but this time using the
pointer with the correct signature deduced from the
signed-but-corrupted pointer.

What perhaps could have happened was that the incorrect signature
could have been one of only two predefined patterns, choosing one or
other with a 50:50 chance but with a 100% chance of being wrong -- eg.,
choose a repeating pattern except where one bit is definitely set to the
opposite value of the corresponding bit in the correct signature.  This
leaks one bit of the correct signature, which is at least better than
the previous solution.

Alternatively, leak nothing but risk producing the correct signature
when that signature happens to collide with the fixed fill pattern.  This sounds statistically reasonable but may have unintended consequences.

But if you can repeatedly loop over the same code pulling out the results of re-signing your guesses, you could also just do that until the value you put in comes beck unmodified.

Supposing the attacker only gets an in-memory view of the pointers, what we want to mitigate that is for the in-register view to clearly denote bad pointers, even temporarily when they won't raise a fault, but without causing the in-memory pointers to be changed when they're transformed back and forth through an invalid pointer.  Then the attacker can't tell good signatures from bad signatures so easily. 

Of course invalid points have nearly the same coding space as signed pointers, so such a bijective transform must at least be _nearly_ feasible.  Even if 3/4 of bad signatures are eliminated from the search by being corrupted in the transform that still hides the correct signature among many fakes.


A naive approach would be for the signing and testing operations to modify the pointer only if it has the correct input form, and otherwise leave it at its original value.  This won't quite work because your can inject a valid pointer where a signed pointer is expected and the result of testing it will be its original value because the signature is wrong (probably).  Then things would proceed as if testing has succeeded because the result will be a valid pointer.  So you need additional rules that for both operations, when given a faulty input, must alter their output iff the output would otherwise be valid, otherwise leave it as its original value.  Given a valid input always modify it to a valid output.

Sounds reasonable, but it needs further thought.

To reason on this further I propose a 27-state system.  All combinations of {signed (intentional), signed (coincidental), unsigned}, {valid (intentional), valid (coincidental), invalid}, and {modified (intentional), modified (evasive), unmodified} (maybe there are more modified states, but the point is we want to maximise the case where modifications cancel).  Formalising the transitions through each pointer operation and walking them all through normal and subversive paths.

The original weakness is a thing I found years ago (and duly reported) and has also been documented in a [Project Zero blog post][].

If you read the pointer authentication spec there are other troublesome cases described which might be used in combination to interesting effect.  There's a mitigation I proposed involving tracking call paths to make replay harder, but which wouldn't mitigate what I describe here.  Another approach might be to use a shadow stack (the same one as the CFI return stack, I guess) of random values to be used as tweaks on the signing function, which could be unique on every entry into a function and saved for the duration of the function but not saved on the stack which is vulnerable to exfiltration (this is important because the random values might be predictable once you capture some).

[Project Zero blog post]: <https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html>
