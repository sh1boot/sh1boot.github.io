---
layout: post
title: That time I found a weakness in Arm pointer authentication
categories: security, cpu, hardware
---
Pointer authentication involves taking things like the return address
and inserting an authentication tag in unused bits -- a cryptographic
signature -- before storing the pointer to memory, and then confirming
that the fingerprint agrees with the pointer destination after loading
it back from memory.

A weakness I noticed a while back was that in some cases the process of
authenticating the pointer does not lead to an immediate fault.  Rather,
if the signature fails then it produces an invalid pointer.
Correspondingly, if you try to sign an invalid pointer then the result
is a pointer with a _deliberately incorrect_ signature.

You see both of these cases joined end-to-end with function tail call
optimisation.  Where one function ends by calling another function, it
jumps directly to the beginning of the next function without ever
returning from itself.  It just has to restore the return address to the
link register before the jump, so that the next function returns to
where the current function should return.

The problem was in the definition of that deliberate incorrectness.  It
turns out it was defined as a predictable modification on a correct
signature.  So if you can insert your own return address, but then
tail-call-optimise your way into another function then the new function
will see your return address with the predictable modification on a
correct signature.  If you can exfiltrate that then you can fix it and
reinsert it as a correctly-signed return address of your choosing.

What probably should have happened was that the incorrect signature
should have been one of only two predefined patterns, choosing one or
other with a 50:50 chance but with a 100% chance of being wrong -- eg.,
choose a repeating pattern except where one bit is set to the opposite
value of the corresponding bit in the correct fingerprint.  This leaks
one bit of the correct fingerprint, which is at least better than the
previous solution.  Alternatively, leak nothing but risk producing a
valid signature when that signature happens to collide with the fixed
fill pattern.

This all happened years ago, and I reported it, and the same
vulnerability has been documented in a [Project Zero blog post][], so I
don't mind disclosing it now.

[Project Zero blog post]: <https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html>
