---
layout: post
title: That time I found a weakness in Arm pointer authentication
categories: security, cpu, hardware
---
Pointer authentication involves taking things like the return address
and inserting an authentication tag into unused bits -- a cryptographic
signature -- before storing the pointer to memory, and then confirming
that the signature agrees with the pointer destination after loading it
back from memory and before using it again.

A weakness I found was that in some cases the process of verifying the
signature does not lead to an immediate fault.  Rather, if the signature
fails then it produces an invalid pointer.  Correspondingly, to prevent
misuse of this situation, if you try to sign an invalid pointer then the
result is a pointer with a _deliberately incorrect_ signature.

You see both of these cases working together with function tail call
optimisation.  Where one function ends by calling another function, it
can jump directly to the beginning of the next function instead of
calling the next function and then returning once that function returns
to it.  Instead, it just has to restore the return address to the link
register before the jump, so that the next function returns to where the
current function should return.  Before doing the jump, the calling
function will pop the return address and validate it, but if it's
corrupt then all it does is make the pointer invalid without raising a
fault.  The fault will instead happen when the called function tries to
use the corrupt return address.

The problem was in the definition of that deliberate incorrectness when
signing an invalid pointer.  It turns out it was defined as a
predictable modification on a correct signature.  So if you can insert
your own return address when you don't know the correct signature, but
then tail-call-optimise your way into another function then the new
function will see your return address with the predictable modification
on a correct signature.  If you can exfiltrate that then you can fix it
and reinsert it as a correctly-signed return address of your choosing.

It's hard to set up, though, because your opportunity to reinsert the
corrected pointer may be limited, and you may need to find a way to
escape the second function without it trying to use the un-fixed
pointer.  Thankfully C++ exceptions and `longjmp()` provide such
opportunities.  You just have to hope the code has exception paths which
don't tear down the program leading to a change of keys on your next
attempt.

What probably should have happened was that the incorrect signature
should have been one of only two predefined patterns, choosing one or
other with a 50:50 chance but with a 100% chance of being wrong -- eg.,
choose a repeating pattern except where one bit is definitely set to the
opposite value of the corresponding bit in the correct signature.  This
leaks one bit of the correct signature, which is at least better than
the previous solution.

Alternatively, leak nothing but risk producing the correct signature
when that signature happens to collide with the fixed fill pattern.

I tried to reason out a way to produce a random signature which didn't
leak that extra bit by producing a random number which could be anything
except for the correct value ("random" being derived from a hash of
invariant properties of the specific fault combined with a secret), but
the complexity to protect just one bit of the signature wasn't
reasonable.

This all happened years ago, and I reported it, and the same
vulnerability has been documented in a [Project Zero blog post][], so I
don't mind disclosing it now.

[Project Zero blog post]: <https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html>
